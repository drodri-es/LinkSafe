
// This file is generated by Firebase Studio.
'use server';
/**
 * @fileOverview This file contains the Genkit flow for automatically fetching website title and favicon when a user adds a new bookmark.
 *
 * - autoFillBookmarkDetails - A function that handles fetching the website title and favicon.
 * - AutoFillBookmarkDetailsInput - The input type for the autoFillBookmarkDetails function.
 * - AutoFillBookmarkDetailsOutput - The return type for the autoFillBookmarkDetails function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const AutoFillBookmarkDetailsInputSchema = z.object({
  url: z.string().url().describe('The URL of the website to fetch details from.'),
});
export type AutoFillBookmarkDetailsInput = z.infer<typeof AutoFillBookmarkDetailsInputSchema>;

const AutoFillBookmarkDetailsOutputSchema = z.object({
  title: z.string().optional().describe('The title of the website.'),
  favicon: z.string().optional().describe('The favicon URL of the website.'),
});
export type AutoFillBookmarkDetailsOutput = z.infer<typeof AutoFillBookmarkDetailsOutputSchema>;

export async function autoFillBookmarkDetails(input: AutoFillBookmarkDetailsInput): Promise<AutoFillBookmarkDetailsOutput> {
  return autoFillBookmarkDetailsFlow(input);
}

const getWebsiteDetails = ai.defineTool({
  name: 'getWebsiteDetails',
  description: 'Fetches the title and favicon of a website given its URL.',
  inputSchema: z.object({
    url: z.string().url().describe('The URL of the website.'),
  }),
  outputSchema: z.object({
    title: z.string().optional().describe('The title of the website.'),
    favicon: z.string().optional().describe('The favicon URL of the website.'),
  }),
}, async (input) => {
  try {
    const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(input.url)}`;
    const response = await fetch(proxyUrl);
    if (!response.ok) {
        throw new Error(`Failed to fetch: ${response.statusText}`);
    }
    const html = await response.text();

    // Extract title
    const titleMatch = html.match(/<title>(.*?)<\/title>/i);
    const title = titleMatch ? titleMatch[1] : undefined;

    // Extract favicon - look for <link rel="icon" ...> or <link rel="shortcut icon" ...>
    let favicon: string | undefined;
    const faviconMatch = html.match(/<link[^>]*rel=["'](shortcut\s+)?icon["'][^>]*href=["']([^"']+)["']/i);
    
    if (faviconMatch) {
      favicon = faviconMatch[2];
      //Ensure favicon is a fully qualified URL
      if (favicon && !favicon.startsWith('http')) {
        const url = new URL(input.url);
        if (favicon.startsWith('//')) {
          favicon = `${url.protocol}${favicon}`;
        } else if (favicon.startsWith('/')) {
          favicon = `${url.origin}${favicon}`;
        } else {
          favicon = `${url.origin}/${favicon}`;
        }
      }
    } else {
        // If no link tag is found, try to get favicon.ico from the root
        const url = new URL(input.url);
        favicon = `${url.origin}/favicon.ico`;
    }

    // Final check to see if the constructed favicon URL is reachable
    try {
        if(favicon) {
            const faviconResponse = await fetch(favicon, { method: 'HEAD' });
            if (!faviconResponse.ok) {
                favicon = undefined;
            }
        }
    } catch (e) {
        favicon = undefined;
    }


    return { title, favicon };
  } catch (error: any) {
    console.error('Error fetching website details:', error.message);
    // Return empty details on failure so the process can continue
    return { title: undefined, favicon: undefined };
  }
});

const autoFillBookmarkDetailsPrompt = ai.definePrompt({
  name: 'autoFillBookmarkDetailsPrompt',
  tools: [getWebsiteDetails],
  prompt: `Use the getWebsiteDetails tool to get the title and favicon for the given URL.
URL: {{{url}}}`,
  input: {schema: AutoFillBookmarkDetailsInputSchema},
  output: {schema: AutoFillBookmarkDetailsOutputSchema},
});

const autoFillBookmarkDetailsFlow = ai.defineFlow(
  {
    name: 'autoFillBookmarkDetailsFlow',
    inputSchema: AutoFillBookmarkDetailsInputSchema,
    outputSchema: AutoFillBookmarkDetailsOutputSchema,
  },
  async input => {
    const {output} = await autoFillBookmarkDetailsPrompt(input);
    // Even if the tool fails, we should return an empty object, not null.
    return output || { title: undefined, favicon: undefined };
  }
);
